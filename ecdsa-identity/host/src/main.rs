use clap::{Parser, Subcommand};
use client_sdk::helpers::risc0::Risc0Prover;
use contract_identity::{actions::IdentityAction, IdentityContractState};
use sdk::api::APIRegisterContract;
use sdk::BlobTransaction;
use sdk::ProofTransaction;
use sdk::{ContractInput, Digestable};

// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods_identity::{GUEST_ELF, GUEST_ID};

use crate::utils::handle_secp384r1_identity;
mod utils;

#[derive(Parser)]
#[command(author, version, about, long_about = None)]
#[command(propagate_version = true)]
struct Cli {
    #[command(subcommand)]
    command: Commands,

    #[clap(long, short)]
    reproducible: bool,

    #[arg(long, default_value = "http://localhost:4321")]
    pub host: String,

    #[arg(long, default_value = "ecdsa_identity")]
    pub contract_name: String,
}

#[derive(Subcommand)]
enum Commands {
    RegisterContract {},
    RegisterIdentity {
        account: String,
        password: String,
    },
    VerifyIdentity {
        account: String,
        password: String,
        nonce: u32,
    },
}

#[tokio::main]
async fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let cli = Cli::parse();

    let client = client_sdk::rest_client::NodeApiHttpClient::new(cli.host).unwrap();

    let contract_name = &cli.contract_name;

    let prover = Risc0Prover::new(GUEST_ELF);

    match cli.command {
        Commands::RegisterContract {} => {
            // Build initial state of contract
            let initial_state = IdentityContractState::new();
            println!("Initial state: {:?}", initial_state);

            // Send the transaction to register the contract
            let res = client
                .register_contract(&APIRegisterContract {
                    verifier: "risc0".into(),
                    program_id: sdk::ProgramId(sdk::to_u8_array(&GUEST_ID).to_vec()),
                    state_digest: initial_state.as_digest(),
                    contract_name: contract_name.clone().into(),
                })
                .await
                .unwrap();

            println!("✅ Register contract tx sent. Tx hash: {}", res);
        }
        Commands::RegisterIdentity { account, password } => {
            // Fetch the initial state from the node
            let initial_state: IdentityContractState = client
                .get_contract(&contract_name.clone().into())
                .await
                .unwrap()
                .state
                .into();

            println!("Initial state {:?}", initial_state.clone());
            println!("User {:?}", account.clone());

            // Handle secp384r1 signed identity

            let (pub_key, signature) =
                handle_secp384r1_identity(&account, &password, b"Hyle Registration").unwrap();

            let identity = format!("{}.{}", pub_key, contract_name);

            // ----
            // Build the blob transaction
            // ----

            let action = IdentityAction::RegisterIdentity { signature };

            let blobs = vec![sdk::Blob {
                contract_name: contract_name.clone().into(),
                data: sdk::BlobData(
                    bincode::encode_to_vec(action, bincode::config::standard())
                        .expect("failed to encode BlobData"),
                ),
            }];
            let blob_tx = BlobTransaction {
                identity: identity.into(),
                blobs: blobs.clone(),
            };

            // Send the blob transaction
            let blob_tx_hash = client.send_tx_blob(&blob_tx).await.unwrap();
            println!("✅ Blob tx sent. Tx hash: {}", blob_tx_hash);

            // ----
            // Prove the state transition
            // ----

            // Build the contract input
            let inputs = ContractInput {
                initial_state: initial_state.as_digest(),
                identity: blob_tx.identity,
                tx_hash: blob_tx_hash,
                private_input: vec![],
                tx_ctx: None,
                blobs: blobs.clone(),
                index: sdk::BlobIndex(0),
            };

            // Generate the zk proof
            let proof = prover.prove(inputs).await.unwrap();

            let proof_tx = ProofTransaction {
                proof,
                contract_name: contract_name.clone().into(),
            };

            // Send the proof transaction
            let proof_tx_hash = client.send_tx_proof(&proof_tx).await.unwrap();
            println!("✅ Proof tx sent. Tx hash: {}", proof_tx_hash);
        }
        Commands::VerifyIdentity {
            account,
            password,
            nonce,
        } => {
            {
                // Fetch the initial state from the node
                let initial_state: IdentityContractState = client
                    .get_contract(&contract_name.clone().into())
                    .await
                    .unwrap()
                    .state
                    .into();

                let message_blob = sdk::Blob {
                    contract_name: contract_name.clone().into(),
                    data: sdk::BlobData(
                        bincode::encode_to_vec(
                            IdentityAction::VerifyIdentity {
                                signature: None,
                                nonce,
                            },
                            bincode::config::standard(),
                        )
                        .expect("failed to encode BlobData"),
                    ),
                };

                let message = format!("{} {:?}", &message_blob.contract_name, &message_blob.data.0);

                let message = format!("verify {} {}", nonce, message);

                let (pub_key, signature) =
                    handle_secp384r1_identity(&account, &password, &message.as_bytes()).unwrap();

                let identity = format!("{}.{}", pub_key, contract_name);

                // ----
                // Build the blob transaction
                // ----

                let action = IdentityAction::VerifyIdentity {
                    signature: Some(signature),
                    nonce,
                };

                let blobs = vec![
                    sdk::Blob {
                        contract_name: contract_name.clone().into(),
                        data: sdk::BlobData(
                            bincode::encode_to_vec(action, bincode::config::standard())
                                .expect("failed to encode BlobData"),
                        ),
                    },
                    message_blob,
                ];
                let blob_tx = BlobTransaction {
                    identity: identity.into(),
                    blobs: blobs.clone(),
                };

                // Send the blob transaction
                let blob_tx_hash = client.send_tx_blob(&blob_tx).await.unwrap();
                println!("✅ Blob tx sent. Tx hash: {}", blob_tx_hash);

                // ----
                // Prove the state transition
                // ----

                // Build the contract input
                let inputs = ContractInput {
                    initial_state: initial_state.as_digest(),
                    identity: blob_tx.identity,
                    tx_hash: blob_tx_hash.clone(),
                    private_input: vec![],
                    tx_ctx: None,
                    blobs: blobs.clone(),
                    index: sdk::BlobIndex(0),
                };

                // Generate the zk proof
                let proof = prover.prove(inputs).await.unwrap();

                let proof_tx = ProofTransaction {
                    proof,
                    contract_name: contract_name.clone().into(),
                };

                // Send the proof transaction
                let proof_tx_hash = client.send_tx_proof(&proof_tx).await.unwrap();
                println!("✅ Proof tx sent. Tx hash: {}", proof_tx_hash);
            }
        }
    }
}
